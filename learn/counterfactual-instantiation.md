# Counterfactual Instantiation

Counterfactual instantiation allows participants to interact, play games, and make conditional payments on decentralized applications (dapps) without having to deploy these dapps' smart contracts to the blockchain at all. This means that they can make many fast transactions to update state and switch from one channelized dapp to another without having to open and close the channel on the blockchain.

The term "counterfactual" here refers to an event that **could** happen, but has not. In generalized state channels, we are "counterfactually instantiating" smart contracts in a sense that these contracts *could* be deployed to the blockchain, but has not. What’s important is that the contracts could be deployed unilaterally *if* there is a dispute. Once the commitments have been signed inside a state channel, participants can act as though it were a final on the blockchain because at any time, they could deploy it to the blockchain. If all is well, the game contract needn’t be deployed at all.

What *does* happen on the main blockchain is that the participants are agreeing to be bound by an off-chain contract by sending deposits into a multisignature wallet. They then enter into a metachannel which can consist of an arbitrary number of subchannels. Each of these subchannels can be thought of as individual state channels that are running dapps. Each subchannel is governed by the counterfactually instantiated dapp logic and conditional payment logic. In case of a dispute, these contracts can *then* be deployed on-chain and resolved.

## On-chain components

### A multisignature wallet
An on-chain multisig holds deposited funds in escrow, its signers being the channel participants. During a consented withdrawal or dispute, a call can be made to this wallet to distributed the deposited funds accordingly. The participants can also make **instant deposits** and **instant withdrawals** into or out of the metachannel by making on-chain transactions to this multisig.

### A registry

An on-chain registry keeps track of counterfactually instantiated contracts. The same instance of this registry is shared among all subchannels. The registry allows participants to:

* Counterfactually instantiate a contract and refer to it without having to deploy it
* Resolve the mapping of counterfactual addresses to Ethereum addresses (similar to how DNS maps domain names to IP addresses). Note that contract addresses are deterministically generated by content. You don’t need to deploy an address to the blockchain in order to obtain the address for it — just compute it’s hash!
* Deploy counterfactually instantiated contracts if there is a dispute, and register the deployed contract on the blockchain


With this setup, the installation and the opening/closing of new dapps (i.e. subchannels) will not require any on-chain transactions. The user experiences channelization by default, taking advantage of the blockchain in a cheaper (no on-chain transactions), instant, and privacy-preserving way.
